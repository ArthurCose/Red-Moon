use super::{IllegalInstruction, NativeError};
use crate::interpreter::{ByteString, MultiValue, TypeName};
use std::borrow::Cow;
use std::rc::Rc;

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

#[derive(Debug, PartialEq, Clone)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub enum RuntimeErrorData {
    IllegalInstruction(IllegalInstruction),
    InvalidRef,
    MissingMain,
    StackOverflow,
    InvalidCall(TypeName),
    MetatableIndexChainTooLong,
    MetatableCallChainTooLong,
    AttemptToIndex(TypeName),
    AttemptToConcat(TypeName),
    NoLength(TypeName),
    InvalidCompare(TypeName, TypeName),
    InvalidArithmetic(TypeName),
    DivideByZero,
    NoIntegerRepresentation,
    InvalidForInitialValue(TypeName),
    InvalidForLimit(TypeName),
    InvalidForStep(TypeName),
    OutOfBounds,
    ResumedDeadCoroutine,
    ResumedNonSuspendedCoroutine,
    #[cfg_attr(feature = "serde", serde(serialize_with = "serialize_multi"))]
    #[cfg_attr(feature = "serde", serde(deserialize_with = "deserialize_multi"))]
    Yield(MultiValue),
    InvalidYield,
    UnhandledYield,
    RequiresNativeFunction,
    /// Bad argument passed to a function. Generated by [MultiValue::unpack_args()] and [MultiValue::unpack_modified_args()]
    BadArgument {
        /// Argument position (usually starts from 1).
        position: usize,
        /// Underlying error returned when converting argument to a Lua value.
        #[cfg_attr(feature = "serde", serde(with = "serde_runtime_error_data_rc"))]
        reason: Rc<RuntimeErrorData>,
    },
    ExpectedType {
        expected: TypeName,
        received: TypeName,
    },
    #[cfg_attr(feature = "serde", serde(serialize_with = "serialize_native_err"))]
    #[cfg_attr(feature = "serde", serde(deserialize_with = "deserialize_native_err"))]
    NativeError(NativeError),
    String(Cow<'static, str>),
    ByteString(ByteString),
    #[cfg(feature = "serde")]
    InvalidTag,
    #[cfg(feature = "serde")]
    FunctionLostInSerialization,
    #[cfg(feature = "serde")]
    #[serde(other)]
    LostInSerialization,
}

#[cfg(feature = "serde")]
use crate::serde_util::{
    impl_serde_deserialize_stub_fn, impl_serde_rc, impl_serde_serialize_stub_fn,
};

#[cfg(feature = "serde")]
impl_serde_rc!(
    serde_runtime_error_data_rc,
    RuntimeErrorData,
    RuntimeErrorData
);

#[cfg(feature = "serde")]
impl_serde_serialize_stub_fn!(serialize_multi, MultiValue);
#[cfg(feature = "serde")]
impl_serde_deserialize_stub_fn!(
    deserialize_multi,
    MultiValue,
    MultiValue {
        values: Default::default()
    }
);

#[cfg(feature = "serde")]
impl_serde_serialize_stub_fn!(serialize_native_err, NativeError);
#[cfg(feature = "serde")]
impl_serde_deserialize_stub_fn!(
    deserialize_native_err,
    NativeError,
    super::RuntimeError::from(RuntimeErrorData::LostInSerialization).into()
);

impl From<IllegalInstruction> for RuntimeErrorData {
    fn from(value: IllegalInstruction) -> Self {
        Self::IllegalInstruction(value)
    }
}

impl std::fmt::Display for RuntimeErrorData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RuntimeErrorData::IllegalInstruction(instruction) => {
                write!(f, "illegal instruction, {instruction}")
            }
            RuntimeErrorData::InvalidRef => write!(f, "invalid ref"),
            RuntimeErrorData::MissingMain => write!(f, "module missing main chunk"),
            RuntimeErrorData::StackOverflow => write!(f, "stack overflow"),
            RuntimeErrorData::InvalidCall(type_name) => {
                write!(f, "attempt to call a {type_name} value")
            }
            RuntimeErrorData::MetatableIndexChainTooLong => {
                write!(f, "'__index' chain too long; possible loop")
            }
            RuntimeErrorData::MetatableCallChainTooLong => {
                write!(f, "'__call' chain too long; possible loop")
            }
            RuntimeErrorData::AttemptToIndex(type_name) => {
                write!(f, "attempt to index a {type_name} value")
            }
            RuntimeErrorData::AttemptToConcat(type_name) => {
                write!(f, "attempt to concatinate a {type_name} value")
            }
            RuntimeErrorData::NoLength(type_name) => {
                write!(f, "attempt to get length of a {type_name} value")
            }
            RuntimeErrorData::InvalidCompare(type_name_a, type_name_b) => {
                write!(f, "attempt to compare {type_name_a} with {type_name_b}")
            }
            RuntimeErrorData::InvalidArithmetic(type_name) => {
                write!(f, "attempt to perform arithmetic on a {type_name} value")
            }
            RuntimeErrorData::DivideByZero => write!(f, "attempt to divide by zero"),
            RuntimeErrorData::NoIntegerRepresentation => {
                write!(f, "number has no integer representation")
            }
            RuntimeErrorData::InvalidForInitialValue(type_name) => {
                write!(
                    f,
                    "bad 'for' initial value (number expected, got {type_name})"
                )
            }
            RuntimeErrorData::InvalidForLimit(type_name) => {
                write!(f, "bad 'for' limit (number expected, got {type_name})")
            }
            RuntimeErrorData::InvalidForStep(type_name) => {
                write!(f, "bad 'for' step (number expected, got {type_name})")
            }
            RuntimeErrorData::OutOfBounds => write!(f, "position out of bounds"),
            RuntimeErrorData::ResumedDeadCoroutine => write!(f, "cannot resume dead coroutine"),
            RuntimeErrorData::ResumedNonSuspendedCoroutine => {
                write!(f, "cannot resume non-suspended coroutine")
            }
            RuntimeErrorData::Yield(_) => write!(f, "in progress yield"),
            RuntimeErrorData::InvalidYield => {
                write!(f, "attempt to yield from outside a coroutine")
            }
            RuntimeErrorData::UnhandledYield => write!(f, "unhandled yield"),
            RuntimeErrorData::RequiresNativeFunction => {
                write!(f, "this action is only applicable to a native function")
            }
            RuntimeErrorData::BadArgument { position, reason } => {
                write!(f, "bad argument #{position} ({reason})")
            }
            RuntimeErrorData::ExpectedType { expected, received } => {
                write!(f, "{expected} expected, got {received}")
            }
            RuntimeErrorData::NativeError(err) => write!(f, "{err}"),
            RuntimeErrorData::String(s) => write!(f, "{s}"),
            RuntimeErrorData::ByteString(s) => write!(f, "{s}"),
            #[cfg(feature = "serde")]
            RuntimeErrorData::InvalidTag => {
                write!(f, "invalid tag, expecting string or primitive")
            }
            #[cfg(feature = "serde")]
            RuntimeErrorData::FunctionLostInSerialization => {
                write!(
                    f,
                    "function lost during serialization, use rehydrate to refill native functions"
                )
            }
            #[cfg(feature = "serde")]
            RuntimeErrorData::LostInSerialization => {
                write!(f, "error information lost during serialization")
            }
        }
    }
}
