use super::{IllegalInstruction, NativeError};
use crate::interpreter::{ByteString, MultiValue, TypeName};
use std::borrow::Cow;
use std::rc::Rc;

#[derive(Debug, PartialEq, Clone)]
pub enum RuntimeErrorData {
    IllegalInstruction(IllegalInstruction),
    InvalidRef,
    MissingMain,
    StackOverflow,
    InvalidCall(TypeName),
    MetatableIndexChainTooLong,
    MetatableCallChainTooLong,
    AttemptToIndex(TypeName),
    AttemptToConcat(TypeName),
    NoLength(TypeName),
    InvalidCompare(TypeName, TypeName),
    InvalidArithmetic(TypeName),
    DivideByZero,
    NoIntegerRepresentation,
    InvalidForInitialValue(TypeName),
    InvalidForLimit(TypeName),
    InvalidForStep(TypeName),
    OutOfBounds,
    ResumedDeadCoroutine,
    ResumedNonSuspendedCoroutine,
    Yield(MultiValue),
    InvalidYield,
    UnhandledYield,
    YieldMissingContinuation,
    /// Bad argument passed to a function. Generated by [MultiValue::unpack_args()] and [MultiValue::unpack_modified_args()]
    BadArgument {
        /// Argument position (usually starts from 1).
        position: usize,
        /// Underlying error returned when converting argument to a Lua value.
        reason: Rc<RuntimeErrorData>,
    },
    ExpectedType {
        expected: TypeName,
        received: TypeName,
    },
    NativeError(NativeError),
    String(Cow<'static, str>),
    ByteString(ByteString),
}

impl From<IllegalInstruction> for RuntimeErrorData {
    fn from(value: IllegalInstruction) -> Self {
        Self::IllegalInstruction(value)
    }
}

impl std::fmt::Display for RuntimeErrorData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RuntimeErrorData::IllegalInstruction(instruction) => {
                write!(f, "illegal instruction, {instruction}")
            }
            RuntimeErrorData::InvalidRef => write!(f, "invalid ref"),
            RuntimeErrorData::MissingMain => write!(f, "module missing main chunk"),
            RuntimeErrorData::StackOverflow => write!(f, "stack overflow"),
            RuntimeErrorData::InvalidCall(type_name) => {
                write!(f, "attempt to call a {type_name} value")
            }
            RuntimeErrorData::MetatableIndexChainTooLong => {
                write!(f, "'__index' chain too long; possible loop")
            }
            RuntimeErrorData::MetatableCallChainTooLong => {
                write!(f, "'__call' chain too long; possible loop")
            }
            RuntimeErrorData::AttemptToIndex(type_name) => {
                write!(f, "attempt to index a {type_name} value")
            }
            RuntimeErrorData::AttemptToConcat(type_name) => {
                write!(f, "attempt to concatinate a {type_name} value")
            }
            RuntimeErrorData::NoLength(type_name) => {
                write!(f, "attempt to get length of a {type_name} value")
            }
            RuntimeErrorData::InvalidCompare(type_name_a, type_name_b) => {
                write!(f, "attempt to compare {type_name_a} with {type_name_b}")
            }
            RuntimeErrorData::InvalidArithmetic(type_name) => {
                write!(f, "attempt to perform arithmetic on a {type_name} value")
            }
            RuntimeErrorData::DivideByZero => write!(f, "attempt to divide by zero"),
            RuntimeErrorData::NoIntegerRepresentation => {
                write!(f, "number has no integer representation")
            }
            RuntimeErrorData::InvalidForInitialValue(type_name) => {
                write!(
                    f,
                    "bad 'for' initial value (number expected, got {type_name})"
                )
            }
            RuntimeErrorData::InvalidForLimit(type_name) => {
                write!(f, "bad 'for' limit (number expected, got {type_name})")
            }
            RuntimeErrorData::InvalidForStep(type_name) => {
                write!(f, "bad 'for' step (number expected, got {type_name})")
            }
            RuntimeErrorData::OutOfBounds => write!(f, "position out of bounds"),
            RuntimeErrorData::ResumedDeadCoroutine => write!(f, "cannot resume dead coroutine"),
            RuntimeErrorData::ResumedNonSuspendedCoroutine => {
                write!(f, "cannot resume non-suspended coroutine")
            }
            RuntimeErrorData::Yield(_) => write!(f, "in progress yield"),
            RuntimeErrorData::InvalidYield => {
                write!(f, "attempt to yield from outside a coroutine")
            }
            RuntimeErrorData::UnhandledYield => write!(f, "unhandled yield"),
            RuntimeErrorData::YieldMissingContinuation => {
                write!(f, "yield missing continuation callback")
            }
            RuntimeErrorData::BadArgument { position, reason } => {
                write!(f, "bad argument #{position} ({reason})")
            }
            RuntimeErrorData::ExpectedType { expected, received } => {
                write!(f, "{expected} expected, got {received}")
            }
            RuntimeErrorData::NativeError(err) => write!(f, "{err}"),
            RuntimeErrorData::String(s) => write!(f, "{s}"),
            RuntimeErrorData::ByteString(s) => write!(f, "{s}"),
        }
    }
}
